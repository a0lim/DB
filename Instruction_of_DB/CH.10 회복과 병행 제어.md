## 1 트랜잭션
### 1.1 트랜잭션의 개념
* 트랜잭션(transaction)  
: 하나의 작업을 수행하기 위해 필요한 DB의 연산들을 모아놓은 것  
    - DB에서 논리적인 작업의 단위
    - 장애가 발생했을 때 데이터를 복구하는 작업의 단위
    - 일반적으로 DB 연산은 SQL문으로 표현 -> 작업 수행에 필요한 SQL 문들의 모임

* 의의  
    - DBMS에서 DB가 항상 정확하고 일관된 상태를 유지할 수 있도록 다양한 기능 제공에 기여
    - DB의 회복과 병행 제어 가능
    - 다수의 사용자가 동시에 사용하더라도 항상 모순이 없는 정확한 데이터를 유지
    - DB에 장애가 발생하더라도 빠른 시간 내에 원래의 상태로 복구  

![image](https://user-images.githubusercontent.com/104348646/187903815-b93543f5-6617-4272-ab2b-cc0d384a37d4.png)

### 1.2 트랜잭션의 특성
* 트랜잭션의 특성(= ACID 특성)  
    : 트랜잭션이 성공적으로 처리되어 DB의 무결성과 일관성을 보장하기 위해 만족해야 하는 특성들

#### 1.2.1 원자성(atomicity)  
  : 트랜잭션을 구성하는 연산들이 모두 정상적으로 실행되거나 하나도 실행되지 않아야 한다
* all-or-nothing
* 트랜잭션이 작업을 완료하지 못했다면, 지금까지 실행한 연산들 모두 처리를 취소하고 DB를 트랜잭션 작업 전의 상태로 되돌림
* 트랜잭션을 구성하는 연산 중 일부만 처리한 결과를 DB에 반영하지 않음
* 장애가 발생 했을 때, DB의 원래 상태로 복수하는 회복 기능이 필요  
![image](https://user-images.githubusercontent.com/104348646/187903837-a941ef29-0d2f-45ea-81bd-266ef14055e4.png)

#### 1.2.2. 일관성(consistency)  
  : 트랜잭션이 성공적으로 수행된 후에도 DB가 일관성 있는 상태를 유지해야 함
* 트랜잭션이 수행되는 과정 중에는 DB가 일시적으로 일관된 상태가 아닐 수는 있음
* 트랜잭션의 수행이 성공적으로 완료된 후에는 DB가 일관된 상태를 유지해야 함  
![image](https://user-images.githubusercontent.com/104348646/187903872-4ec431be-5d08-4399-8bb8-12dc7c682979.png)

#### 1.2.2. 격리성(isolation) (= 고립성)  
  : 현재 수행 중인 트램잭션이 완료될 때까지 트랜잭션이 생성한 중간 연산 결과에 다른 트랜잭션들이 접근할 수 없음
* 일반적으로 여러 트랜잭션이 동시에 수행되지만, 각 트랜잭션이 독립적으로 수행될 수 있도록 다른 트랜잭션의 중간 연산 결과에 서로 접근하지 못함
* 트랜잭션이 순서대로 하나씩 수행되는 것과 같은 결과를 얻을 수 있도록 제어하는 기능이 필요  
![image](https://user-images.githubusercontent.com/104348646/187903922-98d6b57a-65fd-4f00-b349-3d33c08eaa55.png)

#### 1.2.4. 지속성(durability) (= 영속성)  
  : 트랜잭션이 성공적으로 완료된 수 DB에 반영한 수행 결과는 어떠한 경우에도 손실되지 않고 영구적이어야 한다  
* 시스템에 장애가 발생하더라도 트랜잭션 작업 결과는 DB에 그대로 남아있어야 함
* 시스템에 장애가 발생했을 때, DB를 원래 상태로 복구하는 회복 기능이 필요

#### 1.2.5 트랜잭션의 특성을 지원하는 DBMS의 기능  
![image](https://user-images.githubusercontent.com/104348646/187903950-11aea44d-f72c-402e-9fe7-6bcbe5580298.png)  

### 1.3 트랜잭션의 연산
* commit 연산  
    : 트랜잭션의 수행이 성공적으로 완료되었음을 선언하는 연산  
    - commit 연산이 실행된 후에야 트랜잭션의 수행 결과가 DB에 반영되어, DB가 일관된 상태를 지속적으로 유지  
![image](https://user-images.githubusercontent.com/104348646/187903970-061cdc3b-abd8-4d9e-b51d-c24d78aa10a5.png)

* rollback 연산  
    : 트랜잭션의 수행이 실패했음을 선언하는 연산  
    - 트랜잭션이 지금까지 실행한 연산의 결과가 취소되고, 트랜잭션이 수행되기 전의 상태로 다시 돌아감  
![image](https://user-images.githubusercontent.com/104348646/187904007-c98fcd84-326c-42e9-a1d8-c916067a7ebb.png)

### 1.4 트랜잭션의 상태  
![image](https://user-images.githubusercontent.com/104348646/187904126-6e5cb740-15b6-4765-b831-48589b9a0c24.png)  

* 활동 상태(active)  
    : 트랜잭션이 수행을 시작하여 현재 수행 중인 상태  
    - 상황에 따라 부분 완료 상태나 실패 상태가 됨
* 부분 완료 상태(partitially committed)  
    : 트랜잭션의 마지막 연산이 실행된 직후의 상태  
    - 트랜잭션의 모든 연산을 처리한 상태
    - 아직 트랜잭션의 수행이 완료되지 않음
        + 모든 연산의 처리가 끝났지만, 트랜잭션이 수행한 최종 결과를 DB에 아직 반영하지 않은 상태
    - 상황에 따라 완료 상태나 실패 상태가 됨

* 완료 상태(commited)  
    : 트랜잭션이 성공적으로 완료되어 commit 연산을 실행한 상태  
    - 트랜잭션이 수행한 최종 결과를 DB에 반영하고, DB가 새로운 일관된 상태가 되면서 트랜잭션이 종료

* 실패 상태(failed)  
    : 하드웨어, 소프트웨어의 문제나, 트랜잭션 내부의 오류 등의 이유로 장애가 발생하여 트랜잭션의 수행이 중단된 상태  
    - 트랜잭션이 더는 정상적으로 수행을 계속할 수 없음

* 철회 상태(aborted)  
    : 트랜잭션의 수행이 실패하여 rollback 연산을 실행한 상태  
    - 지금까지 실행한 트랜잭션의 연산을 모두 취소하고, 트랜잭션이 수행되기 전의 DB 상태로 되돌림
    - 상황에 따라 다시 수행되거나 폐기
        + 트랜잭션의 내부 문제가 아닌 경우
            : 다시 수행
        + 하드웨어나 소프트웨어의 오류
            : 철회 -> 철회된 트랜잭션을 다시 시작
        + 트랜잭션이 처리하려는 데이터가 DB에 존재하지 않거나 논리적인 오류가 원인인 경우  
            : 철회된 트랜잭션을 폐기  

## 2 장애와 회복
* 회복(recovery)  
    : 장애가 발생했을 때 DB를 장애가 발생하기 전의 일관된 상태로 복구시킴  
    - 트랜잭션의 특성을 보장하고, DB를 일관된 상태로 유지하기 위한 기능

### 2.1 장애의 유형
* 장애(failure)  
    : 시스템이 제대로 동작하지 않는 상태  
![image](https://user-images.githubusercontent.com/104348646/187904186-429ef3e3-b0a9-4bf7-9cb8-4df2f9262928.png)

### 2.2 데이터베이스의 저장 연산
* DB는 기본적으로 저장 장치에 저장됨
    - 일반적으로는 비휘발성 저장 장치(디스크)에 상주
    - 트랜잭션이 DB 데이터를 처리하는 경우
        + 데이터를 디스크에서 메인 메모리로 가져와 이를 처리한 후 그 결과를 다시 디스크로 보냄  
![image](https://user-images.githubusercontent.com/104348646/187904207-5c3abebe-206d-45cd-8ee2-97b5c25dc1e4.png)

* input(X)  
    : 디스크 블록에 저장되어 있는 데이터 X를 메인 메모리 버퍼 블록으로 이동시키는 연산  
* output(X)  
    : 메인 메모리 버퍼 블록에 있는 데이터 X를 디스크 블록으로 이동시키는 연산  
* read(X)  
    : 메인 메모리 버퍼 블록에 저장되어 있는 데이터 X를 프로그램의 변수로 읽어오는 연산  
* write(X)  
    : 프로그램의 변수 값을 메인 메모리 버퍼 블록에 있는 데이터 X에 기록하는 연산  

![image](https://user-images.githubusercontent.com/104348646/187904238-9fbd3640-60de-4a80-9bda-53fd17bd3dc4.png)  
![image](https://user-images.githubusercontent.com/104348646/187904278-e9fe6c17-52d8-4a61-b947-a120725c0381.png)  

### 2.3 회복 기법
* 회복 관리자(recovery manager)  
    : 회복을 담당  
    - 장애 발생을 탐지, DB 복구 기능을 제공
    - 복구하는 동안은 DB에 접근할 수 없으므로, 빠른 시간 내에 이루어져야 함

#### 2.3.1 회복을 위한 연산
* 데이터 중복
    - DB 회복의 핵심 원리
    - 데이터를 별도의 장소에 미리 복사해두고, 장애로 문제가 발생했을 때 복사본을 이용해 원래의 상태로 복원

* 회복 방법
    - redo 연산  
        : 로그에 기록된 변경 연산 후의 값을 이용하여 변경 연산을 재실행  
    - undo 연산  
        : 로그에 기록된 변경 연산 이전의 값을 이용하여 변경 연산을 취소  

* DB 전체를 복사하는 방법
    - 덤프(dump)  
        : DB 전체를 다른 저장 장치에 주기적으로 복사하는 방법  
        + 디스크와 같은 비휘발성 저장 장치에 DB 복사본을 저장
    - 로그(log)  
        : DB에서 변경 연산이 실행될 때마다 데이터를 변경하기 이전 값과 변경한 이후의 값을 별도의 파일에 기록하는 방법  
* 로그 파일: 로그를 저장한 파일
    - 레코드 단위로 기록
    - 트랜잭션의 수행과 함께 기록됨 (연산은 트랜잭션 단위로 실행되기 때문)
    - 데이터 손실이 발생하지 않는 저장 장치에 저장  

![image](https://user-images.githubusercontent.com/104348646/187906635-7d8b489b-516c-4d57-9649-9df8b91b5bf6.png)  
![image](https://user-images.githubusercontent.com/104348646/187904325-56c1ea20-3ad5-4385-a381-5d42c0826b95.png)  

![image](https://user-images.githubusercontent.com/104348646/187904348-8714b60d-5d13-4bfa-874f-a430863608aa.png)  

#### 2.3.2 로그 회복 기법
데이터를 변경한 연산 결과를 DB에 반영하는 시점에 따른 분류  
![image](https://user-images.githubusercontent.com/104348646/187906674-a14bbd23-9b95-4d81-b146-902128b2b883.png)  
* 즉시 갱신 회복 기법(immediate update)  
    : 트랜잭션 수행 중에 데이터를 변경한 연산의 결과를 데이터 베이스에 즉시 반영  
    - 트랜잭션에서 데이터 변경 연산이 실행되었을 때, 로그 파일에 레코드 기록 후 DB에 연산 반영  
![image](https://user-images.githubusercontent.com/104348646/187904367-53c98d95-3e82-4cbe-9190-7de947f1e0b2.png)

* 두 개의 트랜잭션이 순차척으로 수행된 예제  
    ![image](https://user-images.githubusercontent.com/104348646/187904419-0b3b812e-73b1-4815-8988-f07959b26135.png)
    - 시점 1에서 장애가 발생했을 경우
        + T1 트랜잭션 수행 완료 전
        + T1 트랜잭션에 undo(T1) 실행 필요
        + 로그에 기록된 순서의 반대로 undo 연산 실행
    - 시점 2에서 장애가 발생했을 경우
        + T1 트랜잭션의 수행이 완료 된 상태
        + T1 트랜잭션에 redo(T1), T2 트랜잭션에 undo(T2) 연산 실행
        + undo 연산 실행 후 redo 연산 실행

* 지연 갱신 회복 기법(deferred update)  
    : 트랜잭션이 수행되는 도중 데이터 변경 연산의 결과를 DB에 즉시 반영하지 않고 로그 파일에만 기록해두었다가, 트랜잭션이 부분 완료된 후에 로그에 기록된 내용을 한번에 DB에 반영  
    - 트랜잭션의 수행 도중에 장애가 발생하면, 로그에 기록된 내용만 삭제 -> DB에 반영하기 전이므로 DB에 변화 없음
    - redo 연산만 필요(undo 연산은 필요 없음)  
    ![image](https://user-images.githubusercontent.com/104348646/187904457-17559194-0f3c-4c0f-acab-2ae8e0f9adff.png)
* 두 개의 트랜잭션이 순차척으로 수행된 예제  
    ![image](https://user-images.githubusercontent.com/104348646/187904532-e5ba2b4a-207b-4c52-97d6-1650dd521ec5.png)
    - 시점 1에서 장애가 발생했을 경우
        + T1 트랜잭션 수행 완료 전
        + DB에 반영하기 전 -> 로그 기록 버림 -> T1 트랜잭션 다시 시작
    - 시점 2에서 장애가 발생했을 경우
        + T1 트랜잭션의 수행이 완료 된 상태
        + T1 트랜잭션에 redo(T1) 연산 실행, T2 트랜잭션 로그 기록 버림

#### 2.3.3 검사 시점 회복 기법(checkpoint)
* 로그 회복 기법의 단점
    - DB 회복 시간이 오래 걸림
    - redo 연산을 수행할 필요가 없는 트랜잭션에도 실행함(비효율)

* 검사 시점 회복 기법
    - 로그 회복 기법과 같은 방법으로 로그를 기록하고, 일정 시간 간격으로 검사 시점을 만듦
    - 장애가 발생하면 가장 최근 검사 시점 이전의 트랜잭션에는 회복작업을 수행하지 않고, 이후의 트랜잭션만 회복 작업을 수행
    - 불필요한 회복 작업의 시간을 단축
    - 검사 시점
        + 메인 메모리에 있는 모든 로그 레코드를 안정 저장 장치에 있는 로그 파일에 기록
        + 트랜잭션의 데이터 변경 내용을 DB에 반영
        + 검사 시점을 표시하는 ```<checkpoint L>``` 형식의 로그 레코드를 로그 파일에 기록
            cf) ```<checkpoint L>```: L은 현재 실행되고 있는 트랜잭션의 리스트
    - 장애 발생
        + 로그 파일에서 가장 최근의 ```<checkpoint L>``` 로그 레코드를 찾아 그 이후의 로그 기록에만 회복 작업을 수행
        + ```<checkpoint L>``` 로그 레코드로 회복 작업의 범위를 정함
        + 즉시 갱신 회복 기법이나 지연 갱신 회복 기법을 이용해 회복 작업을 수행

#### 2.3.4 미디어 회복 기법  
  : 디스크에 발생할 수 있는 장애에 대비한 회복 기법  
* 비휘발성 저장 장치인 디스크에 저장
* 데이터 저장
    + 전체 DB 내용을 일정 주기마다 다른 안전한 저장 장치에 복사
* 장애 발생
    + 가장 최근에 복사해둔 덤프 이용
    + 장애 발생 이전의 일관된 DB 상태로 복구
    + 필요에 따라 로그 내용을 토대로 redo 연산 실행
* 단점
    + 고비용
    + CPU 낭비: 복사하는 동안에 트랜잭션 수행을 중단

## 3. 병행 제어
### 3.1 병행 수행과 병행 제어
* 병행 수행(concurrency)  
  : 여러 사용자가 DB를 동시에 공유할 수 있도록, 여러 개의 트랜잭션을 동시에 수행  
    - 여러 트랜잭션들이 차례로 번갈아 수행되는 인터리빙(interleaving) 방식으로 진행
* 병행 제어(concurrency control) (= 동시성 제어)  
  : 여러 개의 트랜잭션이 같은 데이터에 접근하여 연산을 실행하더라도, 문제가 발생하지 않도록 트랜잭션의 수행을 제어  

### 3.2 병행 수행의 문제
#### 3.2.1 갱신 분실(lost update)  
  : 하나의 트랜잭션이 수행한 데이터 변경 연산의 결과를 다른 트랜잭션이 덮어써서 변경 연산이 무효화 됨  
![image](https://user-images.githubusercontent.com/104348646/187904579-425f9d6d-7d40-4c05-b106-8c051103282f.png)  

#### 모순성(inconsistency)  
  : 하나의 트랜잭션이 여러 개의 데이터 변경 연산을 실행할 때 일관성 없는 상태의 DB에서 데이터를 가져와 연산을 실행하여 모순된 결과 발생  
![image](https://user-images.githubusercontent.com/104348646/187904624-691b4e30-bfcc-4492-a8db-70ad8c00451d.png)  

#### 연쇄 복귀(cascading rollback)  
  : 트랜잭션이 완료되기 전에 장애가 발생하여 rollback 연산을 수행하면, 이 트랜잭션이 장애 발생 전에 변경한 데이터를 가져가서 변경 연산을 실행한 또 다른 트랜잭션에도 rollback 연산을 연쇄적으로 실행해야 함  
* 장애가 발생한 트랜잭션이 rollback 연산을 실행하기 전에, 변경한 데이터를 가져가 사용하는 다른 트랜잭션이 수행을 완료하면 rollback 연산 실행이 불가능  
![image](https://user-images.githubusercontent.com/104348646/187904669-21da9286-4977-49d7-b896-df61b0468708.png)  

### 3.3 트랜잭션 스케줄  
  : 트랜잭션에 포함되어 있는 연산들을 수행하는 순서  
* 하나의 트랜잭션 안에 많은 연산들이 포함되어, 여러 가지 스케줄 가능

#### 3.3.1 직렬 스케줄(serial schedule)  
  : 인터리빙 방식을 이용하지 않고 각 트랜잭션별로 연산들을 순차적으로 실행  
* 모든 트랜잭션이 완료될 때까지 다른 트랜잭션의 방해를 받지 않고 독립적으로 수행
* 장점
    - 모두 정확한 결과 도출
* 단점
    - 각 트랜잭션을 독립적으로 수행 -> 병행 수행이라고 보기 어려움

#### 3.3.2 비직렬 스케줄(nonserial schedule)  
  : 인터리빙 방식을 이용하여 트랜잭션들을 병행해서 수행  
* 트랜잭션이 돌아가면서 연산들을 실행
* 어떤 비직렬 스케줄을 선택해서 트랜잭션을 수행하는지가 중요
* 단점
    - 비직렬 스케줄에 따라 갱신 분실, 모순성, 연쇄 복귀 등의 문제 가능성 -> 낮은 정확성

#### 3.3.3 직렬 가능 스케줄(serializable schedule)  
  : 직렬 스케줄과 같이 정확한 결과를 생성하는 비직렬 스케줄  
* 장점
    - 인터리빙 방식을 이용하여 여러 트랜잭션을 병행 수행하면서도, 정확한 결과를 얻음
* 단점
    - 직렬 가능 스케줄인지 여부를 판단하기 어려움
    - 하나씩 수행해보면서 직렬 스케줄과 같은 결과가 나오는지 비교하는 작업 필요

### 3.4 병행 제어 기법
* 여러 트랜잭션을 병행 수행하면서도 정확한 결과를 얻을 수 있는 직렬 가능성을 보장
* 모든 트랜잭션이 따르면 직렬 가능성이 보장되는 규약을 정의
* 장점
    - 트랜잭션 스케줄이 직렬 가능 스케줄인지 미리 검사할 필요 없음

#### 3.4.1 로킹 기법의 개념
* 로킹(locking)
    - 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock 연산을 이용해 제어
* 상호 배제(mutual exclusion): 한 트랜잭션이 먼저 접근한 데이터에 대한 연산을 모두 마칠 때까지, 해당 데이터에 다른 트랜잭션의 접근은 막아 직렬 가능성을 보장
* lock 연산
    - 트랜잭션이 사용할 데이터에 대한 독점권을 가지기 위해 사용
* unlock 연산
    - 트랜잭션이 데이터에 대한 독점권을 반납하기 위해 사용

* 기본 로킹 규약
    - 해당 데이터에 lock 연산을 실행하여 독점권을 획득
    - 트랜잭션이 데이터에 read 또는 write 연산을 실행하기 전에 lock 연산을 실행
    - 다른 트랜잭션이 이미 lock 연산을 실행한 데이터는 다시 lock 연산 실행 불가
    - 트랜잭션이 lock 연산을 통해 데이터에 대한 모든 연산의 수행이 끝나면, unlock 연산을 실행해서 독점권을 반납
    - unlock 연산으로 독점권을 반납한 후에 다른 트랜잭션이 해당 데이터에 점근 가능
    - 데이터에 lock 연산을 실행한 트랜잭션만 해당 데이터에 대한 unlock 연산 실행 가능 -> 다른 트랜잭션에 독점권을 뺏기지 않음

* 로킹 단위  
    : lock 연산을 실행하는 대상 데이터의 크기  
    - 크게는 전체 DB에서 작게는 DB를 구성하는 속성까지 다양한 크기의 데이터를 대상으로 실행 가능
        + 릴레이션, 튜플도  가능
    - 전체 DB에 lock 연산을 실행하는 경우
        + 제어가 간단
        + DB에 한 트랜잭션만 수행 -> 병행 수행으로 보기 어려움
    - 속성에 lock 연산을 실행하는 경우
        + 많은 수의 트랜잭션이 병행 수행 가능
        + 제어가 복잡
    - 시스템에 따라 적절한 로킹 단위를 선택하는 것이 중요

* lock 연산의 종류
    - 단순히 읽어오는 read 연산은 여러 트랜잭션이 동시에 실행해도 됨 -> read 연산을 동시에 실행하는 것을 허용
    - 공용(shcared ) lock
        + 해당 데이터에 read 연산은 실행 가능하지만, write 연산은 실행 불가능
        + 해당 데이터에 다른 트랜잭션도 공용 lock 연산을 동시에 실행 가능
        + 데이터에 대한 사용건을 여러 트랜잭션이 함께 가질 수 있음
    - 전용(exclusive) lock
        + 해당 데이터에 read 연산과 write 연산을 모두 실행 가능
        + 해당 데이터에 다른 트랜잭션은 어떤 lock 연산도 실행 불가(공용, 전용 모두)
        + 전용 lock 연산을 실행한 트랜잭션만 해당 데이터에 대한 독점권을 가질 수 있음
    - lock 연산의 양립성  
        ![image](https://user-images.githubusercontent.com/104348646/187904720-0cee498c-7f38-435b-8a1a-293ceff2d16f.png)
    - 기본 로킹 규약의 한계
        + 모든 트랜잭션이 기본 로킹 규약을 지키더라도 잘못된 결과를 얻을 수 있음  
        ![image](https://user-images.githubusercontent.com/104348646/187904763-fcdead69-f508-45c2-aa1b-5577e0df733b.png)

#### 3.4.2 2단계 로킹 규약(2PLP: Phase Locking Protocol)  
  : 기본 로킹 규약의 문제를 해결하고 트랜잭션의 직렬 가능성을 보장하기 위한 새로운 규약을 추가한 것  
* lock, unlock 연산의 단계
    - 확장 단계
        + 트랜잭션이 lock 연산만 실행할 수 있고, unlock 연산은 실행할 수 없는 단계
    - 축소 단계
        + 트랜잭션이 unlock 연산만 실행할 수 있고, lock 연산은 실행할 수 없는 단계
    - 트랜잭션이 처음 수행 -> 확장 단계 -> lock 연산만 실행
    - 교착 상태 발생 주의
* 교착 상태(deadlock)  
    : 트랜잭션들이 상대가 독점하고 있는 데이터에 unlock 연산이 실행되기를 서로 기다리면서 트랜잭션의 수행을 중단하고 있는 상태    

![image](https://user-images.githubusercontent.com/104348646/187904804-35462951-6f09-4503-9f47-1cfa6fe2d6ed.png)
