## 1. DB 설계 단계
* 사용자들의 요구 사항을 잘 분석 & DB의 논리적, 물리적 구조를 설계해야 함  
: 사용자들의 요구 사항을 고려하여 DB를 생성하는 과정  
* 기준
    - 데이터의 일관성과 무결성 유지
    - 사용자가 이해하기 쉽고 접근하기 편함
    - DB를 실제로 사용하는 구성원들의 요구 사항을 만족

* DB 설계 방법
    - E-R 모델과 릴레이션 변환 규칙을 이용한 DB 설계
    - 정규화를 이용한 DB 설계


### E-R 모델과 릴레이션 변환 규칙을 이용한 DB 설계 과정

![image](https://user-images.githubusercontent.com/104348646/187331558-f542d2d4-7fc4-4028-a4eb-19d26bf12b56.png)  

* 1단계: 요구 사항 분석
    - 조직의 구성원들이 DB를 사용하는 용도를 파악
    - 결과물
        + 요구 사항 명세서  
        : 사용자에게 필요한 데이터의 종류와 처리 방법 같은 다양한 요구 사항을 수집하고 이를 분석한 결과를 작성한 것  

* 2단계: 개념적 설계
    - 사용자의 요구 사항을 개념적 데이터 모델을 이용해 표현
    - 개념적 데이터 모델  
        : 개발에 사용할 DBMS의 종류에 독립적이면서, 중요한 데이터 요소와 데이터 요소 간의 관계를 표현할 때 사용  
        + 일반적으로 E-R 모델을 개념적 데이터 모델로 사용 
    - 주요 작업
        + 사용자의 요구 사항을 분석한 결과를 E-R 다이어그램으로 표현  

* 3단계: 논리적 설계
    - 개발에 사용할 DBMS에 적합한 논리적 데이터 모델을 이용해 개념적 구조를 기반으로 논리적 구조를 설계
    - DBMS의 종류에 따라 네트워크 데이터 모델, 계층 데이터 모델, 관계 데이터 모델, 객체지향 데이터 모델 등도 사용 가능
        + 일반적으로 관계 데이터 모델을 이용 
    - 주요 작업
        + 논리적 모델링(데이터 모델링)  
        : 논리적 설계 단계에서 E-R 다이어그램을 릴레이션(테이블) 스키마로 변환하여 DBMS가 처리할 수 있도록 함  
 
* 4단계: 물리적 설계
    - DB의 물리적 구조  
        : DB를 저장 장치에 실제로 저장하기 위한 내부 저장 구조와 접근 경로 등  
    - 저장 장치에 적합한 저장 레코드와 인덱스의 구조 등을 설계하고, 저장된 데이터와 인덱스에 빠르게 접근하게 할 수 있는 탐색 기법 등을 정의
    - 주요 작업
        + DB를 구축할 컴퓨터 시스템의 저장 장치와 운영체제의 특성을 고려하여, 효율적인 성능을 지원하면서도 사용할 DBMS로 구현이 가능한 물리적인 구조를 설계
    - 응답 시간을 최소화하고 저장 공간을 효율적으로 활용하면서 DB 시스템의 처리 능력을 향상시켜야 함
    - 결과물
        + 내부 스키마(물리적 스키마)
        : 물리적 설계의 결과물인 물리적 구조

* 5단계: 구현
    - DBMS에서 SQL로 작성한 명령문을 실행하여 DB를 실제로 생성
    - 테이블이나 인덱스 등을 생성할 때 사용되는 데이터 정의어(DDL) 사용

## 2. 요구 사항 분석
* 목적
    - DB에 대한 사용자들의 요구 사항을 수집하고 분석하여, 개발할 DB의 용도를 명확히 파악
* 주요 사용자의 범위 결정
    - 사용자마다 요구 사항이 매우 다양하므로 실제 사용자의 범위를 정해 불필요한 요구 사항을 수집하지 않도록 해야함
* 해당 사용자가 조직에서 수행하는 업무를 분석
    - 업무 관련 필요한 데이터가 무엇인지, 데이터에 어떤 처리가 필요한지 등의 요구사항 수집
    - 사용자들과의 면담, 설문지 배포, 업무 관련 문서의 분석 등의 방법 사용
* 요구 사항 명세서 작성
    - 다각도의 분석이 끝난 후에 분석 결과를 문서화
* 의의
    - 사용자가 요구하는 DB의 용도를 결정짓는 설계의 첫 단계
    - 품질 좋은 DB 개발을 위해 중요
    - 분석이 잘못되면 쓸모 없는 DB가 개발되어 다시 개발해야 함

![image](https://user-images.githubusercontent.com/104348646/187333519-e57d43f1-5f5b-43b2-839e-b808c62736ad.png)  

## 3. 개념적 설계
: 요구 사항 분석 단계의 결과물(요구 사항 명세서)를 개념적 데이터 모델을 이용하여 표현
* 개념적 데이터 모델  
: 요구 사항의 분석 결과에서, 앞으로 DB에 저장해둘 필요가 있다고 판단되는 데이터 요소를 추출하고 데이터 요소간의 관계를 파악하여 이를 표현
    - 개발에 사용할 DBMS의 종류에 독립적
    - 일반적으로 E-R 모델을 이용
* 주요 작업
    - 요구 사항 분석 결과를 기반으로 현실 세계에서 중요한 데이터 요소인 개체를 추출한 후, 개체 간의 관계를 결정하여 이를 E-R 다이어그램으로 표현
* 개념적 모델링  
    : 사용자의 요구 사항을 개념적 데이터 모델로 변환하는 작업  
    - 과정  
        : 개체와 속성 추출 -> 각 개체의 주요 속성과 키 속성 선별 -> 개체 간의 관계 결정 -> E-R 다이어그램으로 표현  
* 개념적 구조(개념적 스키마)
    : E-R 다이어그램과 같이 개념적 데이터 모델로 표현된 개념적 설계의 결과물

### 3.1 개체와 속성 추출
* 개체  
    : 저장할만한 가치가 있는 중요 데이터를 가진 사람이나 사물 등  
    - 개념적 모델링에서 가장 중요한 요소
* 추출 과정
    - 요구 사항의 문장들에서 명사를 찾음
    - 조직의 업무 처리와 관련이 적은 일반적이고 광범위한 의미는 제외
    - 의미가 같은 명사들 중에서 대표 명사 하나만 선택
    - 찾아낸 명사를 개체와 속성으로 정확히 분류

### 3.2 관계 추출
* 관계  
    : 개체 간의 의미 있는 연관성  
* 추출 과정
    - 요구 사항의 문장들에서 동사를 찾음
    - 조직의 업무 처리와 관련이 적은 일반적이고 광범위한 의미는 제외
    - 의미가 같은 명사들 중에서 대표 명사 하나만 선택
* 매핑 카디널리티와 참여 특성 결정
* 매핑 카디널리티
    : 관계를 맺고 있는 두 개체에서 각 개체 인스턴스가 관계를 맺고 있는 상대 개체의 개체 인스턴스의 개수
    - 종류
        + 일대일(1:1), 일대다(1:n), 다대다(n:m)
* 참여 특성
    : 개체가 관계에 필수적으로 참여하는지, 선택적으로 참여하는지를 의미

![image](https://user-images.githubusercontent.com/104348646/187331727-fce6e21e-66b3-4752-92f0-037d97c2ead1.png)  

* 관계의 E-R 다이어그램  
![image](https://user-images.githubusercontent.com/104348646/187331757-f1f11eec-554f-4a73-b031-232e488fe31c.png)  
![image](https://user-images.githubusercontent.com/104348646/187331781-943baa25-93e7-4756-be6f-e817b04b4dc9.png)  
![image](https://user-images.githubusercontent.com/104348646/187331807-5d7959d7-8c89-4482-b9d8-784d6f15af5a.png)  

### 3.3 E-R 다이어그램 작성
* 개념적 스키마(개념적 설계 단계의 결과물)  

![image](https://user-images.githubusercontent.com/104348646/187331855-4c73b1f0-5cd3-46a6-a0e2-28b7a86c19a6.png)  

## 4. 논리적 설계
* 목적
    - DBMS 독립적인 개념적 스키마로 부터 사용할 DBMS가 처리할 수 있는 DB이 논리적 구조 설계
* 데이터 모델
    - DBMS의 종류에 따라 네트워크 데이터 모델, 계층 데이터 모델, 관계 데이터 모델, 객체지향 데이터 모델 등을 사용 가능
        + 일반적으로 관계 데이터 모델을 사용
* 주요 작업
    - 관계 데이터 모델을 이용하여 개념적 설계 단계의 결과물인 E-R 다이어그램을 관계 데이터 모델의 릴레이션스키마(= 테이블 스키마)로 변환
* 논리적 모델링(데이터 모델링)  
    : E-R 다이어그램을 논리적 데이터 모델로 변환하는 작업  
* 논리적 구조(논리적 스키마)  
    : 논리적 데이터 모델로 표현된 논리적 설계의 결과물  
* E-R 다이어그램과 관계 데이터 모델 차이
    - 표현
        + E-R 다이어그램: 개체와 관계를 구분
        + 관계 데이터 모델: 개체와 관계를 구분하지 않고 모두 릴레이션으로 표현
    - 다중 값 속성과 복합 속성
        + E-R 다이어그램: 표현 허용
        + 관계 데이터 모델: 표현 허용하지 않음
    - 릴레이션 표현 방법
        + 일대일, 일대다, 다대다에 따라 릴레이션으로 표현하는 방법이 다름
        + E-R 다이어그램을 릴레이션으로 변환할 때 적용할 수 있는 5가지 규칙 & 정규화 과정으로 검증 작업 수행 필요

### 4.1 릴레이션 스키마 변환 규칙
#### 4.1.1 규칙 1: 모든 개체는 릴레이션으로 변환한다
* 각 개체를 하나의 릴레이션으로 변환
    - 개체 이름 -> 릴레이션의 이름
    - 개체 속성 -> 릴레이션의 속성
        + 개체가 복합 속성인 경우에는 복합 속성을 구성하고 있는 단순 속성만 릴레이션의 속성으로 변환
    - 개체의 키 속성 -> 릴레이션의 기본키

#### 4.1.2 규칙 2: 다대다(n:m) 관계는 릴레이션으로 변환한다
* 다대다 관계를 하나의 릴레이션으로 변환
    - 관계의 이름 -> 릴레이션의 이름
    - 관계의 속성 -> 릴레이션의 속성
        + 릴레이션들의 기본키를 관계 릴레이션에 포함시키고 외래키로 지정 (관계를 맺고 있는 개체가 무엇인지 중요하기 때문)
        + 이 외래키들을 조합하여 관계 릴레이션의 기본키로 지정
        + 기본키들의 이름이 같으면 하나는 이름을 변경 (한 릴레이션에 있는 속성은 이름이 모두 달라야 함)  
        + 
![image](https://user-images.githubusercontent.com/104348646/187332118-3ce6f048-ce90-4c3c-950d-bb5fc6a1fd5f.png)  
  
#### 4.1.3 규칙 3: 일대다(1:n) 관계는 외래키로 표현한다
* 릴레이션으로 변환하지 않고 외래키로만 표현

* 규칙 3-1: 일반적인 일대다 관계는 외래키로 표현한다
    - 일대다(1:n) 관계의 1측 개체 릴레이션의 기본키를 가져와 n측 개체 릴레이션에 포함시키고 외래키로 지정
        + 관계의 속성들도 n측 릴레이션에 포함
        + 해당 릴레이션의 원래 개체 속성과 이름이 같으면 이름 변경

![image](https://user-images.githubusercontent.com/104348646/187332136-d29cf2e5-cf71-403d-90f1-96c4642aa66a.png)  
  
* 규칙 3-2: 약한 개체가 참여하는 일대다 관계는 외래키를 포함해서 기본키로 지정한다
    - 일대다(1:n) 관계의 1측 개체 릴레이션의 기본키를 가져와 n측 개체 릴레이션에 포함시키고 외래키로 지정
        + 관계의 속성들도 n측 릴레이션에 포함
        + n측 개체 릴레이션이 가지고 있던 키 속성과 외래키를 조합하여 기본키를 지정해야 함 (약한 개체는 오너 개체야 따라 존재 여부가 결정되기 때문)  

![image](https://user-images.githubusercontent.com/104348646/187332086-c458e17b-ce2a-4b49-ad1b-a0063367e4f4.png)  
  
#### 4.1.4 규칙 4: 일대일(1:1) 관계를 외래키로 표현한다
* 규칙 4-1: 일반적인 일대일 관계는 외래키를 서로 주고 받는다
  - 관계가 가지고 있던 속성은 두 릴레이션 모두에 포함
  - 불필요한 데이터 중복이 발생
    + 한 릴레이션에만 포함시켜도 됨
    + 포함시킬 릴레이션 선택은 자유롭게 선택

![image](https://user-images.githubusercontent.com/104348646/187332187-7fbcb4ae-52c1-4341-bf34-e51267ac86e6.png)  
  
* 규칙 4-2: 일대일 관계에 필수적으로 참여하는 개체의 릴레이션만 외래키를 받는다
    - 관계에 필수적으로 참여하는 개체에 해당하는 릴레이션이 선택적으로 참여하는 개체에 해당하는 릴레이션의 기본키를 받아 외래키로 지정
        + 관계가 가지고 있는 속성은 필수적으로 참여하는 개체의 릴레이션에 함께 포함

ex) 남자는 반드시 결혼 해야하고 여자는 하지 않아도 되는 경우  
![image](https://user-images.githubusercontent.com/104348646/187332211-43d2fdf5-9211-4000-a229-4fd5eec8b4c4.png)  
  
* 규칙 4-3: 모든 개체가 일대일 관계에 필수적으로 참여하면 릴레이션 하나로 합친다
    - 두 개체에 해당하는 릴레이션들을 하나로 합쳐 표현
        + 관계의 이름 -> 릴레이션의 이름
        + 관계에 참여하는 두 개체들의 속성들도 관계 릴레이션에 모두 포함
        + 두 개체 릴레이션의 키 속성을 조합 -> 관계 릴레이션의 기본 키

![image](https://user-images.githubusercontent.com/104348646/187332233-43822871-d37f-4e86-a86e-65888f64b63c.png)  
  
#### 4.1.5 규칙 5: 다중 값 속성은 릴레이션으로 변환한다
* 다중 값을 가지는 속성을 허용하지 않음
    + 다중 값 속성은 그 속성을 가지고 있느 개체에 해당하는 릴레이션이 아닌 별도의 릴레이션을 만들어 포함
    + 다중 값 속성으로 표현된 속성과 그 속성을 가지고 있는 개체에 해당하는 릴레이션의 기본키로 가져와 포함하고 외래키로 지정
    + 기본키는 다중 값 속성과 외래키를 조합하여 지정

![image](https://user-images.githubusercontent.com/104348646/187332251-2103207e-6a0c-46d8-9956-5ca5c712d5b2.png)  

ex) 다중 값 속성인 부하직원 속성을 릴레이션으로 변환하는 과정  

![image](https://user-images.githubusercontent.com/104348646/187332264-55d56500-939e-4bee-9ca0-41f081beb5d7.png)  
![image](https://user-images.githubusercontent.com/104348646/187332291-5c652961-1aa6-430f-be7b-32aeae792d96.png)  

#### 4.1.6 기타 고려 사항
* 속성이 많은 관계는 관계의 유형에 상관 없이 릴레이션으로 변환을 고려
    - 일대일(1:1) 관계를 다대다 관계처럼 릴레이션으로 변환
        + 관계의 이름, 속성을 릴레이션의 이름, 속성으로 변환
        + 관계를 맺고 있는 두 개체에 해당하는 릴레이션들의 기본키를 가져와 포함시키고 이를 외래키로 지정
        + 단, 릴레이션의 개수가 많아져 DBMS의 부담이 커짐 -> 가능한 릴레이션으로 변환하지 않는 것을 권장
    ![image](https://user-images.githubusercontent.com/104348646/187332327-5ff47022-6f0f-4e54-9088-282995f2db5f.png)   

    - 순환 관계가 다대다 관계일 경우에는 릴레이션으로 변환, 일대일이나 일대다 관계일 경우에는 외래키로 표현  
    ![image](https://user-images.githubusercontent.com/104348646/187332347-6cc3e907-1634-4819-948c-e3f265d215fe.png)  

### 4.2 릴레이션 스키마 변환 규칙을 이용한 논리적 설계
![image](https://user-images.githubusercontent.com/104348646/187332370-d5b4e633-15c1-4159-b027-10aad5e8251d.png)  

* 규칙 1: 모든 개체는 릴레이션으로 변환한다  
![image](https://user-images.githubusercontent.com/104348646/187332963-dca4d558-f78d-48e6-b181-5f89c3325808.png)  

* 규칙 2: 다대다(n:m) 관계는 릴레이션으로 변환한다  
![image](https://user-images.githubusercontent.com/104348646/187332404-52b8c5b6-5ecb-4133-ba1d-8d77aad77b5f.png)   

* 규칙 3: 일대다(1:n) 관계는 외래키로 표현한다  
![image](https://user-images.githubusercontent.com/104348646/187332428-a6806a02-cb40-4e26-9987-b35c5d85a7aa.png)  

* 규칙 4: 일대일(1:1) 관계를 외래키로 표현한다  
* 규칙 5: 다중 값 속성은 릴레이션으로 변환한다  

* 테이블 명세서 
    : 최종적으로 변환된 릴레이션 스키마에 대해 속성의 데이터 타입과 같이 길이, 널 값 허용 여부, 기본값, 제약조건 등을 결정
    - ex) MS SQL 서버를 DBMS로 사용한다고 가정  
    ![image](https://user-images.githubusercontent.com/104348646/187332444-0ab14ce0-d5d2-44ce-ad8f-1b2474b450e5.png)  

## 5. 물리적 설계와 구현
* 주요 작업
    - 하드웨어나 운영체제의 특성을 고려하여 필요한 인덱스의 구조나 내부 저장 구조 등에 대한 물리적인 구조를 설계
    - DBMS를 이용해 SQL 문을 작성하고 이를 실행하여 DB를 생성
    - ex) 회원 릴레이션의 구현을 위한 SQL 문
```
CREATE TABLE 회원 (
    회원아이디  VARCHAR(20)    NOT NULL,
    비밀번호    VARCHAR(20)    NOT NULL,
    이름    VARCHAR(10)    NOT NULL,
    나이    INT,
    직업    VARCJAR(20),
    등급    VARCHAR(10)    NOT NULL    DEFAULT 'silver',
    적립금  INT    NOT NULL    DEFAULT 0,
    PRIMARY KEY(회원아이디),
    CHECK (나이 >= 0),
    CHECK (등급 IN ('silver', 'gold', 'vip'))
);
```
