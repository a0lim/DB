## 1. 관계 데이터 모델의 개념

### 1.1 관계 데이터 모델의 기본 용어
* 릴레이션(relation)

![5-1](https://user-images.githubusercontent.com/104348646/180170518-d7cc22da-83ff-4cc5-8efc-64034be6cd5a.JPG)

#### 1.1.1 속성
* 릴레이션의 열(= 속성)( =어트리뷰트= attribute)
  - 릴레이션에서 중요한 데이터들을 의미하는 속성
  - 서로 다른 이름을 이용하여 구별
  - 파일 관리 시스템 관점에서 해당 파일의 필드(field)에 대응하는 개념

#### 1.1.2 튜플
* 릴레이션의 행(= 튜플= tuple)
  - 개체의 인스턴스
  - 파일 관리 시스템 관점에서 해당 파일의 레코드(record)에 대응하는 개념

#### 1.1.3 도메인(domain)
: 속성 하나가 가질 수 있는 모든 값의 집합
* 특정 속성이 가질 수 있는 모든 원자 값의 모임
* 특정 속성이 가질 수 있는 값이 매우 많은 경우(ex. 고객 이름)
  - 데이터 타입으로 정의  
  - ex) 문자 타입(CHAR), 정수 타입(INT)  
  - cf) <-> 특정 속성의 값이 제한된 경우(소수인 경우): 속성 값들의 집합으로 정의  

#### 1.1.4 널(null)
: 특정 투플의 속성 값을 모르거나 적합한 값이 없는 경우에 사용
  - 숫자 0이나 공백 문자와는 구별

#### 1.1.5 차수(degree)
: 하나의 릴레이션에서 속성의 전체 개수
  - 모든 릴레이션은 최소 1 이상의 차수를 가져야 함
  - 일반적으로 정적인 특성을 가짐(자주 변하지 않음)

#### 1.1.6 카디널리티(cardinality)
: 하나의 릴레이션에서 튜플의 전체 개수
  - 투플이 0인 릴레이션도 존재 가능  
  - 일반적으로 동적인 특성을 가짐 ( ∵ 삽입/삭제 횟수가 많음)  

### 1.2 릴레이션과 데이터베이스의 구성

#### 1.2.1 릴레이션 스키마(relation schema) (= 릴레이션 내포= relation intension)
: 릴레이션의 이름과 모든 속성의 이름으로 정의하는 릴레이션의 논리적 구조
  * 릴레이션의 구조 파악에 용이
  * 일반적인 표현 방식
  : 릴레이션이름(속성이름1, 속성이름2, … , 속성이름n)

#### 1.2.2 릴레이션 인스턴스(relation instance) (= 릴레이션 외연= relation extension) (= 릴레이션)
: 어느 한 시점에 릴레이션에 존재하는 튜플들의 집합
  * 릴레이션의 내용 파악에 용이
  * 동적인 특성: DBMS 내부적으로 튜플의 삽입/삭제/수정/검색이 자주 발생

#### 1.2.3 DB 스키마와 DB 인스턴스
* 일반적으로 DB는 여러 개의 릴레이션으로 구성됨
* DB에 저장된 전체 스키마/데이터 내용을 의미

### 1.3 릴레이션의 특성
1. 튜플의 유일성
: 하나의 릴레이션에는 동일한 튜플이 존재할 수 없다

1. 키(key)  
: 튜플이 유일하도록 구별하기 위해 선정되는 속성(들)  
   - 키를 이용해 원하는 튜플에 접근이 쉬움  

2. 튜플의 무순서  
: 하나의 릴레이션에서 튜플 사이의 순서는 무의미하다  
    * 튜플들의 순서가 바뀌어도 상관없음 ( ∵ 위치가 아닌 내용으로 검색)  

3. 속성의 무순서  
: 하나의 릴레이션에서 속성 사이의 순서는 무의미하다  
    * ∵ 위치가 아닌 속성의 이름으로 접근  

4. 속성의 원자성  
: 속성 값으로 원자 값만 사용할 수 있다  
    * 하나의 속성은 다중 값을 가질 수 없음  
        - ex) 직업: 학생(O) / 회사원, 학생(X)  

### 1.4 키의 종류

![5-8](https://user-images.githubusercontent.com/104348646/180170551-4410a854-be1d-4d3f-9559-21728f4b2c5f.JPG)

#### 1.4.1 슈퍼키(super key)
* 유일성(unique)을 만족
* 구별할 수 있는 속성 값이 있는 모든 속성 및 속성 집합  
  ex) 고객아이디(O) / 고객이름(X) / (고객아이디, 고객이름) (O)
* 불필요한 속성의 값까지 확인하는 비효율적인 작업을 하는 경우가 있음

#### 1.4.2 후보키(candidate key)
* 유일성과 최소성(minimality)을 만족  
: 튜플을 구별하기 위한 최소한의 속성들로 구성

* 구별하기 위해 꼭 필요한 최소한의 속성들로 이루어짐  
  ex) 고객아이디(O) / 고객이름(X) / (고객아이디, 고객이름) (X)

#### 1.4.3 기본키(primary key)
* 여러 후보키 중에서 기본적으로 반드시 사용할 키
* 후보키가 2개 이상인 경우에는 DB 사용 환경을 고려해 선택
* 기본키 선택의 기준
  - 널 값을 가질 수 있는 속성이 포함된 후보키는 부적합
  - 값이 자주 변경될 수 있는 속성이 포함된 후보키는 부적합
  - 단순한 후보키를 선택
      ex) 고객아이디, 주소: 후보키 / 고객아이디를 기본키로 설정
#### 1.4.4 대체키(alternate key)
* 기본키로 선택되지 못한 후보키들  
  ex) 고객아이디: 기본키 / 고객이름, 주소: 대체키

#### 1.4.5 외래키(foreign key)
: 다른 릴레이션의 기본키를 그대로 참조하는 속성의 집합

![5-9](https://user-images.githubusercontent.com/104348646/180170591-4b15c3ae-a321-4a89-b5cd-1a72eb7291c8.JPG)

* 참조하는 릴레이션의 외래키와 참조되는 릴레이션의 기본키 속성 이름은 다를 수 있음
* 외래키 속성과 기본키 속성의 도메인은 같아야 함(for 비교 연산)

* 외래키 자신이 속한 릴레이션의 기본키를 참조하는 경우도 있음
* 기본키가 아니기 때문에 null 값을 가지거나 튜플들이 같은 값을 가질 수 있음

## 2. 관계 데이터 모델의 제약
* 무결성 제약조건(integrity constraint)
: 데이터를 정확하고 유효하게 유지하기 위한 조건
  - DB가 삽입/삭제/수정 연산으로 상태가 변하더라도 반드시 지켜야 하는 기본 제약 사항
  - 권한이 있는 사용자들의 잘못된 요구로부터 데이터의 정확성을 보호

### 2.1 개체 무결성 제약조건(entity integrity constraint)
: 기본키를 구성하는 모든 속성은 널 값을 가질 수 없다
  * 새 튜플을 삽입하거나 기존 기본키의 속성을 변경할 때, 기본키에 null 값이 포함되어 있을 시 수행 거부
  * 새로운 릴레이션을 생성할 때마다 기본키를 어떤 속성들로 구성할 것인지 수동으로 DBMS에 알려줘야 함

### 2.2 참조 무결성 제약조건(referential integrity constraint)
: 외래키는 참조할 수 없는 값을 가질 수 없다
  * 참조되는 릴레이션의 기본키에는 없는 속성 값을 가진 외래키 불가능  
  ex) 기본키의 속성값: apple, banana, carrot, orange / 외래키의 속성값: apple, carrot, cherry => (X)
  * 외래키의 속성이 null인 경우에는 가능  
  ex) 기본키의 속성값: apple, banana, carrot, orange / 외래키의 속성값: apple, carrot, null => (O)
  * 외래키에 참조할 수 없는 값이 있는 경우  
    - 문제가 된 튜플의 삽입 수행을 거부/삭제
    - 문제가 된 속성의 값을 null로 변경
  * 어떤 속성들이 외래키이고 어떤 릴레이션의 기본키를 참조하는 것인지 DBMS에 알리면 자동으로 처리됨

![5-15](https://user-images.githubusercontent.com/104348646/180170619-0426aa23-7860-4563-b3b6-32fb95d8f5b6.JPG)
