## 1. 객체지향 DB
* 배경
    - 관계 데이터 모델의 기능적 제약 조건과 SQL 표현력 한계
        + CAD(Computer-Aided Design), CAM(Computer-Aided Manufacturing), CAE(Computer-Aided Engineering), CASE(Computer-Aided Software Engineering) 등의 다양한 응용 분야에 부적합
    - 새로운 데이터 모델의 필요성
        + 객체지향 데이터 모델

### 1.1 객체지향 데이터 모델  
  : 객체와 객체 식별자, 속성과 메소드, 클래스, 클래스 계층 및 상속, 복합 객체 등을 지원하는 객체지향 개념에 기반을 둔 데이터 모델  
    - 다양한 응용 분야의 데이터 모델링을 위한 새로운 요구 사항을 지원
    - 의미적으로 관계가 있는 DB 구조를 표현하기 우한 강력한 설계 기능 제공

#### 1.1.1  객체와 객체 식별자
* 객체(Object)  
    : 현실 세계에 존재하는 개체를 추상적으로 표현한 것  
    - 객체 식별자를 특정 객체에 접근하기 위한 유일한 수단으로 사용
* 객체 식별자(OID: Object Identifier)  
    : 각 객체가 시스템 전체에서 유일하게 식별되는 도구  

#### 1.1.2  속성과 메소드
* 객체  
    : 객체지향 데이터 모델을 구성하는 기본 요소  
    - 하나 이상의 속성과 하나 이상의 메소드로 구성
* 속성(attribute)  
    : 해당 객체의 상태를 나타냄  
    - 관계 데이터 모델의 속성과 같은 의미
    - 값을 여러 개 가질 수 있음 <-> 관계 데이터 모델의 속성
    - 사용자가 정의한 클래스뿐만 아니라, 해당 클래스의 하위 클래스도 도메인으로 정의 가능
* 메소드(method)  
    : 객체의 상태를 조작하여 수행할 수 있는 연산  
    - 객체의 속성 값을 검색/추가/삭제/수정 하는 데 주로 사용
    - 프로그래밍 언어에서 함수와 유사한 역할
* 메시지(message)  
    - 특정 객체의 속성과 해당 속성에 대한 메소드에 접근하기 위한 도구
    - 한 객체의 속성 값을 수정하기 위해서는 이 역할을 담당하는 메소드를 실행시키는 메시지를 해당 객체에 보냄
    - 객체에 접근하기 위한 공용 인터페이스 역할을 담당

#### 1.1.3  클래스(class)  
  : 속성과 메소드를 공유하는 유사한 성질의 객체들을 하나로 그룹화한 것  
* 객체(= 클래스 인스턴스 = class instance)(= 객체 인스턴스 = object instance)
    - 클래스의 구성원

#### 1.1.4 클래스 계층과 상속
* 계층(class hierarchy)  
    : 클래스를 단계적으로 세분화(specialization)하여 형성된 클래스 간의 계층관계
    - 상위클래스(superclass): 상위 계층의 클래스
    - 하위클래스(subclass): 하위 계층의 클래스
    - 상위클래스와 하위클래스는 일반적으로 IS-A 관계(A is B)가 성립함
* 상속(inheritance)  
    : 상위클래스의 속성과 메소드를 자신의 모든 하위클래스에 물려주는 개념
    - 클래스 계층 개념에서 상속이라는 객체지향 개념을 지원함
    - 단일 상속: 하위클래스가 단 하나의 상위클래스로부터 속성과 메소드를 상속받음
    - 다중 상속: 여러 개의 상위클래스로부터 속성과 메소드를 상속받음

#### 1.1.5 복합 객체(composite object)  
: 시스템에서 기본으로 제공하지 않는 사용자 정의 클래스(user-defined class)를 도메인으로 하는 속성을 가진 객체  
    - 속성 값으로 다른 객체를 참조함  
        + 복합 객체에서 사용자 정의 클래스를 도메인으로 가지는 속성은 해당 클래스의 객체 인스턴스의 객체 식별자(OID_를 값으로 가짐  
    - 일반적으로 Is-Part-Of 관계가 있는 객체를 표현하는 데 사용함  
    (그림 12-4)  
    
### 1.2 객체지향 질의 모델
* 질의
    - 대상: 클래스
    - 결과: 클래스에 속하는 객체 집합
    - 표현: 클래스, 속성, 메소드, 객체 등
* 오퍼랜드(single operand) 질의
    - 단일 오퍼랜드 질의: 객체지향 DB에서 클래스 하나 또는 클래스 하나와 해당 클래스의 하위클래스 전체를 대상으로 하는 질의
    - 다중 오퍼랜드 질의: 여러 클래스를 대상으로 하는 질의
* 단점: 객체지향 DB의 데이터 모델과 질의어는 표준화되지 못함
    - 객체관계 DB 등장

## 2. 객체관계 DB
* 객체관계 데이터 모델
    : 객체지향 개념과 관계 데이터 모델의 개념을 통합한 것
    - 릴레이션, 객체, 메소드, 클래스, 상속, 캡슐화, 복합 객체 등을 모두 지원함
    - 관계 DB의 표준 질의어인 SQL을 표준으로 채택하여 발전 중
    - 기본 질의어의 기능 + 사용자 정의 타입, 객체, 객체 식별자, 메소드 등의 객체지향 특성
* 객체지향 DB와의 비교
    - 공통점: 객체의 개념을 지원 + 사용자 정의의 타입, 객체 식별자, 상속 등을 포함
    - 차이
        + 객체지향 DB: 객체지향 프로그래밍 개념에 기반 + DB의 기능을 추가
        + 객체관계 DB: 관계 DB에 기반 + 사용자가 더 다양한 데이터 타입을 추가

## 3. 분산 DBS(distributed database system)  
: 물리적으로 분산된 DBS을 네트워크로 연결해, 사용자가 논리적으로는 하나의 중앙 집중식 DBS처럼 사용할 수 있도록 한 것
    
### 3.1 분산 DBS의 구성
(그림 12-5)
* 분산 처리기(distributed processor)  
    : 물리적으로 분산되어 지역별로 필요한 데이터를 처리할 수 있는 지역 컴퓨터(local computer)
    - 지역에서 운영하는 DB를 자체적으로 관리할 수 있는 DBMS를 가짐
* 분산 DB(distrubted database)  
    : 물리적으로 분산된 지역 DB(local database)
    - 보통 해당 지역에서 가장 많이 사용하는 데이터를 저장
    - 각 지역의 분산 처리기에 설치된 DBMS로 관리함
* 통신 네트워크(network)  
    : 지역의 분산 처리기가 이를 통해 자원을 공유함
    - 특정 통신 규약에 따라 데이터를 전송/수신
    - 구조가 데이터 통신에 많은 영향을 줌 -> 효율적 설계 필요

### 3.2 분산 DBS의 주요 목표
* 분산 데이터 독립성(distributed data independency)  
    : DB가 분산되어 있음을 사용자가 인식하지 못하게 하는 것
    - 분산 DBS의 주요 목표
    - 분산 투명성(distribution transparency) 보장 필요  
        : 위치 투명성, 중복 투명성, 단편화 투명성, 병행 투명성, 장애 투명성

#### 3.2.1 위치 투명성(local transparency)  
: DB가 지역적으로 분산되어 있지만, 사용자가 접근하려는 데이터의 실제 저장 위치를 알 필요 없이 DB의 논리적인 이름만으로 데이터에 접근 가능함
    - DBMS의 시스템 카탈로그에서 데이터의 모든 위치 정보를 관리
    - 데이터 접근 요청 처리 방법
        + 다른 지역에 있는 데이터를 가져와 처리
        + 데이터 접근 요청을 하는 트랜잭션을 데이터가 있는 지역으로 보내 처리한 후, 결과 데이터만 가져옴
        + 두 가지 방법을 모두 사용해서 처리
    - 장점
        + 응용프로그램의 처리가 간단해짐: 응용 프로그램이 데이터의 저장 위치를 알 필요 없음
        + 자주 사용하는 데이터는 요청 발생 지역으로 가져가 처리함 -> 효율적
        
#### 3.2.2 중복 투명성(replication transparency)  
: 동일한 데이터가 여러 지역에 중복 저장되더라도, 사용자가 인식하지 못하고, 하나의 DBS에 데이터가 저장된 것처럼 사용함
    - DBMS에서 사용자 모르게 자동으로 중복된 데이터를 처리함
* 데이터 중복의 장단점
    - 장점
        + 한 지역에서 문제가 발생해도 동일한 데이터가 저장된 다른 지역에서 계속해서 작업 수행 가능 -> 신뢰성, 가용성 상승
        + 동일한 데이터가 저장된 여러 지역에서 병렬 처리를 수행 가능 -> 데이터 처리 성능이 향상
        + 데이터 처리 요청이 여러 지역에 분산됨 -> 처리 부담 감소
    - 단점
        + 저장 공간을 많이 필요로 함
        + 데이터 변경시, 중복 저장된 데이터를 모두 함께 변경해야 함 -> 비용 증가 + 데이터 불일치 발생 가능성
* 중복 저장 방법
    - 완전 중복: 동일한 데이터를 둘 이상 지역의 분산 DB에 저장
    - 부분 중복: 일부 데이터만 중복하여 저장
    - 분할 DB: 지역의 분산 DB에 중복되는 데이터가 전혀 없는 경우

#### 3.2.3 단편화 투명성(fragmentation transparency)  
* 단편화(fragmentation)  
    : 하나의 릴레이션을 더 작은 조각으로 나누고, 각 조각을 별개의 릴레이션으로 처리함
    - 각 조각이 전체 릴레이션의 일부가 됨 -> 저장 공간 감축 + 관리할 데이터의 수 감소
    - 데이터 중복의 장점 + 단점을 보완
    - 단편화의 3가지 조건
        + 완전성: 전체 릴레이션의 모든 데이터는 어느 한 조각에는 꼭 속해야 함
        + 회복성: 단편화된 조각들로부터 원래의 전체 릴레이션이 회복 가능해야 함
        + 분리성: 전체 릴레이션의 모든 조각을 서로 중복되지 않게 분리해야 함
    - 단편화 방법
        + 수평적 단편화: 릴레이션을 튜플(행) 단위로 나눔
            (그림 12-7)
        + 수직적 단편화: 릴레이션을 속성(열) 단위로 나눔
            (그림 12-8)
        + 혼합 단편화: 수평적 단편화 + 수직적 단편화

#### 3.2.4 병행 투명성(concurrency transparency)  
: 분산 DB와 관련된 트랜잭션들이 동시에 수행되더라도, 결과는 항상 일관성을 유지함
#### 3.2.5 장애 투명성(failure transparency)  
: 특정 지역에서 문제가 발생하더라도 전체 시스템이 작업을 계속 수행할 수 있음
    
### 3.3 분산 DB의 구조
* 일반 구조
    (그림 12-9)
* 전역 개념 스키마(global conceptual schema)
    : 분산 DB에 저장할 모든 데이터 구조와 제약조건을 정의함
    - 데이터의 분산은 고려하지 않음
    - 관계 데이터 모델의 관점에서 보면, DB 안에 존재하는 모든 릴레이션 스키마의 집합
* 단편화 스키마(fragmentation schema)  
    : 전역 개념 스키마를 (논리적으로) 분할하는 방법인 단편화를 정의
    - 전역 개념 스키마와 각 조각 스키마의 대응 관계를 정의
* 할당 스키마(allocation schema)  
    : 각 조각 스키마의 인스턴스를 물리적으로 저장해야 되는 지역을 정의
* 지역 스키마(local schema)  
    : 지역별로 저장하고 있는 데이터 구조와 제약조건을 정의
    
### 3.4 분산 DB의 질의 처리
* 질의 처리 전략
    - 중앙 집중식 DBS: 베이스가 위치한 디스크에 접근하는 횟수
    - 분산 DBS: 디스크 접근 횟수 + 네트워크에서 데이터를 전송하는 비용 + 하나의 질의문을 분해해 여러 지역에서 병렬 처리하는 성능 이점
    
### 3.5 분산 DBS의 장단점
#### 3.5.1 분산 DBS의 장점
* 신뢰성과 가용성 증대  
    : 장애 발생 시, 장애가 발생하지 않은 다른 지역의 DB를 이용해 작업을 계속 수행함
* 지역 자치성과 효율성 증대  
    - DB를 지역별로 독립적으로 관리 가능
    - 가장 많이 사용하는 지역에 해당 데이터를 분산시켜 저장 -> 데이터 요청에 대한 응답 시간 감소 및 통신 비용 절약 가능
* 확장성 증대  
    : 처리할 데이터의 양이 증가하는 경우, 새로운 지역에 DB를 설치하여 운영 -> 확장이 쉬움
    
#### 3.5.2 분산 DBS의 단점
* 추가로 고려할 사항이 많음 -> 설계 및 구출 비용 증가
* 시스템 관리가 복잡 + 비용
* 중앙 집중식 DBS에는 필요 없는 추가 통신 비용/처리 비용 발생

## 4. 멀티미디어 DBS
* 일반 데이터(숫자, 문자) + 멀티미디어 데이터(영상, 음향, 애니메이션 등)을 모두 효과적으로 저장/처리하는 기능이 필요

### 4.1 멀티미디어 데이터의 특성
* 미디어(media)  
    : 데이터의 타입
* 멀티미디어 데이터(multimedia data)  
    : 여러 미디어의 조합으로 이루어진 데이터
    (표 12-2)
    
* 멀티미디어 데이터의 특성
    - 대용량 데이터
        + 일반적으로 수 킬로바이트 ~ 수십 메가바이트 이상
        + 압축 저장 필요 -> 일반 데이터와는 다른 구조로 별도의 저장 공간을 구성해 관리함
    - 검색 방법이 복잡한 데이터
        + 설명 기반 검색(description-based retrieval)
            : 멀티미디어 데이터의 특성을 나타내는 키워드나 자세한 설명을 멀티미디어 데이터와 함께 저장하고, 검색에 이용함
            + 초기의 멀티미디어 검색 시스템에서 사용됨
            + 많은 양의 멀티미디어 데이터를 처리하기 적합하지 않음
            + 주관적인 설명으로, 같은 멀티미디어 데이터에 대한 설명이 다를 수 있음
        + 내용 기반 검색(content-based retrieval)  
            : 멀티미디어 데이터의 실제 내용(특정 객체)을 이용해 검색하는 방법
            + ex) OOO이 포함된 비디오를 검색
            + 내용에 대한 정보를 추출해서 DB에 저장하는 기술 + 이 정보를 사용해 사용자의 질의를 처리하는 기법이 별도로 필요함
    - 구조가 복잡한 데이터  
        + 원시 데이터(raw data): 텍스트, 그래필, 이미지, 비디오, 오디오 등 기본 타입의 데이터
        + 등록 데이터(registration data): 멀티미디어 데이터의 특성과 필요한 정보르 별도로 추출한 데이터
            + ex) 이미지에서 해상도, 픽셀 수, 색상, 크기, 포멧 등의 정보를 추출한 데이터
            + 원시 데이터를 처리하는 데 도움
        + 서술 데이터(description data): 멀티미디어 데이터를 검색할 때 사용됨
            + ex) 멀티미디어 데이터에 지정된 키워드나 자세한 설명 등
        + 공간/시간적으로 관련되어 있는 경우가 많음 -> 복잡한 관계성을 표현/관리할 기술 필요

### 4.2 멀티미디어 DB의 발전 과정
#### 4.2.1 관계 DB에서의 멀티미디어 데이터 처리
* 멀티미디어 DB 개발 초기에 사용됨
    - GENESIS, STAIRS 등
    - 이진 대형 객체(BLOB: Binary Large Object)라는 새로운 데이터 타입을 지원
* 장점
    - 관계 DB가 제공하는 기술을 그대로 이용 가능
* 단점
    - 멀티미디어 데이터를 단순히 저장/검색하는 일부 기능만 제공 가능
    - 멀티미디어 데이터의 시공간적인 특성의 표현, 다양한 미디어 데이터들의 통합 모델링 기능, 사용자의 요구에 맞는 다양한 연산 표현/조작 기능 제공 불가능

#### 4.2.2 객체지향 DB에서의 멀티미디어 데이터 처리
* 1980년대 후반부터 시도됨
    - ORION, NULTOS, MINOS 등
    - 멀티미디어 데이터를 객체와 클래스로 표현하고, 데이터 추상화와 캡슐화, 상속 등의 개념을 지원
* 단점
    - 멀티미디어 데이터의 복잡하고 다양한 모델링 요구 사항을 완벽히 만족하지 못함

### 4.3 멀티미디어 DBMS의 구성
* DBS의 기본 기능 제공 + 멀티미디어 데이터 특성에 따른 다양한 새로운 사항 고려 필요
    - 대용량 + 시공간적 연속성
        + ex) 동영상: 중간에 끊기지 않고 연속적으로 전달
    - 상용화된 DBMS: UniSQL, 오라클, 인포믹스 O2, DB2 UDB 등
    - 대상으로 하는 미디어 데이터의 유형에 따라 DBMS의 구성이 변화함 -> 다양한 유형의 멀티미디어 데이터 지원이 필요
* 멀티미디어 DBMS의 이용 방식
    - 파일 시스템을 이용  
        : 응용 프로그램에 필요한 멀티미디어 데이터를 파일로 저장/관리
        + 초기에 주로 사용됨
        + 프로그래밍 언어로 데이터를 처리하는 코드를 작성해 응용 프로그램에 포함시킴
        + 장점
            + 다양한 응용 분야에서 사용 가능
        + 단점
            + 데이터를 응용 프로그램에서 직접 관리 필요 -> 개발이 어려움
            + 파일의 단순한 저장 구조에 비해 데이터가 복잡함
            + 데이터의 동시 공유, 회복, 보안 등의 고급 기능 제공 어려움
    - 관계 DBMS를 이용
        + 텍스트 등의 일반 데이터는 관계 DB에 저장, 이미지/비디오 등의 데이터는 파일에 저장
        + 지리 정보 시스템(GIS: Geographical Information Systems)에서 많이 사용함
        + 프로그래밍 언어로 파일에 저장된 데이터에 대한 처리 요청 작성, SQL로 관계 DB에 저장된 데이터에 대한 처리 요청 작성
        + 단점
            + 데이터 처리 요청을 위해 두 가지 방법을 모두 지원해야 함
            + 파일에 저장되는 멀티미디어 데이터에는 고급 기능 제공 어려움
    - 확장된 관계 DBMS를 이용
        + ex) 기존 관계 DBMS에 새로 BLOB 데이터 타입을 추가
        + 장점
            + 모든 멀티미디어 데이터에 DBMS의 고급 기능 제공 가능(불완전)
        + 단점
            + 멀티미디어 데이터의 특성을 반영한 처리 요청을 SQL로 표현하기 어려움
    - 객체지향 DBMS를 이용
        + 장점
            + 멀티미디어 데이터를 처리하는 데 필요한 다양한 기능을 제공
        + 단점
            + 기존 관계 DBMS에서 제공하는 동시성 제어, 질의 최적화, 회복 기능 등의 고급 기능 제공 어려움

### 4.4 멀티미디어 데이터의 질의
* 멀티미디어 DBMS만의 질의 처리 기법이 필요
* 데이터 자체에 대한 질의보다, 멀티미디어 데이터에 대한 설명이나 키워드를 이용한 질의를 주로 사용

#### 4.4.1 멀티미디어 데이터의 질의 유형
* 텍스트 질의  
    - 사용자가 제시한 키워드를 포함하는 문서를 검색하는 질의가 대부분  
* 이미지 질의  
    - 사용자가 제시한 키워드와 관련 있는 이미지를 검색하는 내용 검색
    - 사용자가 제시한 이미지와 유사한 이미지를 검색하는 유사도 검색 질의 
* 비디오 질의
    - 장면을 대상으로 하는 검색 질의  
        ex) 'A', 'B'가 말하는 장면을 검색하는 질의
* 공간 질의
    - 주어진 범위 조건에 맞는 특정 위치를 검색하는 질의
        ex) 'OOO'을 기준으로 5km 이내에 있는 식당을 검색하는 질의
        ex) 'OOO'에서 가장 가까운 식당을 검색하는 질의

#### 4.4.2 멀티미디어 데이터의 질의 처리
* 매칭(matching) 기법  
    : 수학 함수로 저장된 데이터와 질의 조건으로 주어진 데이터 간의 유사도를 계산하여, 유사도가 높은 데이터를 검색
* 랭킹(ranking) 기법  
    : 검색 결과를 질의 조건과의 관련 정도에 따라 정렬
    + 관련성이 높은 결과부터 제공
* 필터링(filtering) 기법  
    : 질의 조건과의 관련성이 적은 데이터를 단계적으로 제거해, 검색 범위를 줄이면서 검색
* 인덱스(index) 기법  
    : 인덱스의 구조를 이용해 질의 조건에 적합한 데이터를 검색
